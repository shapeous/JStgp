<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Objects</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <h1>Everything is on the console!</h1>
    <input type="range" min="0" max="100" value="98" disabled>
    <script>
      var s = {}; // Shapeous app object
      
      console.log("** Function Literal **");
      s.val = undefined;
      s.add = function (a, b) {
        if (a === undefined || b === undefined) {
          throw {
            "name": "UndefinedException",
            "message": "add method needs defined arguments"
          }
        }
        if (typeof a !== 'number' || typeof b !== 'number') {
          throw {
            "name": "TypeException",
            "message": "add method needs number parameters"
          }
        }
        return a + b;
      };
      s.double = function (x) {
        //console.log(this); // Shows that this points to the 's' Object literal
        this.val = x;
        that = this; // Uncomment the 'console.log' in this function to see how, this is necessary.
        
        helper = function () {
          //console.log(this); // Shows that 'this' now points to the Global object within this inner function
          //console.log(that); // Shows how 'that' fixes the issue
          
          that.val = that.add(that.val, that.val);
        };
        
        helper(); // invoke
        return this.val;
      };
      s.power = function pwr(base, ex) {
        return (ex === 0? 1 : base * pwr(base, ex - 1));
      };
      
      console.log(s);
      console.log("add(50,50): " + s.add(50, 50));
      console.log("2^10: " + s.power(2, 10));
      
      console.log("\n** Invocation **");
      console.log("   * Method Invocation Pattern");
      var num = {
        val: 0,
        inc: function (x) {
          this.val += (typeof x === 'number'? x : 1);
        }
      };
      num.inc();
      num.inc(2);
      console.log(num.val);
      
      console.log("\n   * Function Invocation Pattern");
      console.log(s.double(10));
      
      console.log("\n   * Constructor Invocation Pattern");
      s.Animal = function (status) {
        this.status = status;
      };
      // Give all instances of 'Animal' a public method, 'talk'.
      s.Animal.prototype.talk = function () {
        return this.status;
      };
      var Dog = new s.Animal("Woof!");
      var Human = new s.Animal("Hello, There!");
      console.log(Dog.talk());
      console.log(Human.talk());
      console.log(s);
      
      console.log("\n   * Apply Invocation Pattern");
      s.array = [4, 6];
      var sum = s.add.apply(null, s.array); // Lets you construct an array of arguments to invoke a function.
      console.log(sum);
      console.log(s);
      
      s.statusObj = {
        "status": "A-OK"
      };
      var status = s.Animal.prototype.talk.apply(s.statusObj); // We can invoke talk even though 's.statusObj' is not an 'Animal'.
      console.log(status);
      console.log(s);
      
      console.log("\n** Arguments **");
      s.addAll = function () {
        i = undefined, sum = 0;
        for (i = 0; i < arguments.length; i += 1) {
          sum += arguments[i];
        }
        return sum;
      };
      console.log(s.addAll(4,8,15,16,23,42));
      
      console.log("\n** Exceptions **");
      try {
        //console.log(s.add(undefined, undefined)); // [un]comment to see the other exception
        console.log(s.add("",true));
      } catch(e) {
        if (e.name === 'UndefinedException') {
          console.log("*** WTH ***")
        } else if (e.name === 'TypeException') {
          console.log("*** WTF ***")
        }
        console.error(e.name + ": " + e.message);
      }
      
      console.log("\n** Augmenting Types **");
      if (!Number.prototype.integer) {
        Number.prototype["integer"] = function () {
          return Math[this < 0? 'ceil' : 'floor'](this);
        }
      }
      console.log(
        (-10 / 3).integer()
      );
      console.log(Number.prototype);
      
      console.log("\n** Recursion **");
      // This function can fail by exhausting the return stack because JavaScript doesn't currently optimized tail recursion.
      s.hanoi = function hanoi(disc, src, aux, dst) {
        if (disc > 0) {
          hanoi(disc - 1, src, dst, aux);
          console.log("Move disc " + disc + " from " + src + " to " + dst);
          hanoi(disc - 1, aux, src, dst);
        }
      }
      s.hanoi(9, "Src", "Aux", "Dst"); // Chrome completes slowly from 11! - 17! (maybe able to go beyond that). IE11 does not complete starting from 10!.
      
      console.log("\n   ** Walk the DOM");
      s.walkTheDOM = function wtd(node, func) {
        func(node);
        node = node.firstChild;
        while (node) {
          wtd(node, func);
          node = node.nextSibling;
        }
      };
      s.getElementByAttribute = function (att, value) {
        var results = [];
        
        s.walkTheDOM(document.body, function (node) {
          var actual = node.nodeType === 1 && node.getAttribute(att);
          if (typeof actual === 'string' && (actual === value || typeof value !== 'string')) {
            results.push(node);
          }
        });
        return results;
      };
      console.log("get an element with a 'type' attribute and a value of 'range':");
      console.log(s.getElementByAttribute("type", "range")[0]);
      
      s.factorial = function f(n, product) {
        product = product || 1;
        
        if (n < 2) {
          return product;
        }
        return f(n - 1, product * n);
      };
      var n = 170; // Increamenting this value by one causes the function to return 'Infinity'.
      console.log(n + "! = " + s.factorial(n));
   </script>
  </body>
</html>
