<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Inheritance</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <h1>Everything is on the console!</h1>
    <input type="range" min="0" max="100" value="98" disabled>
    
    <ul style="float: right"><p>Click the list items to get the Ordinal (Not working)</p>
      <li>One</li>
      <li>Two</li>
      <li>Three</li>
      <li>Four</li>
    </ul>
    <ul style="float: left">
      <p>Click the list items to get the Ordinal (Working)</p>
      <li>One</li>
      <li>Two</li>
      <li>Three</li>
      <li>Four</li>
    </ul>
    <script>
      var s = {}; // Shapeous app object
      
      console.log("I N H E R I T A N C E");
      
      var Mammal = function (name) { // Mammal is a constructor, that is why it is capitalized.
        this.name =  name;
      };
      
      Mammal.prototype.getName = function () {
        return this.name;
      };
      
      Mammal.prototype.says = function () {
        return this.saying || "";
      };
      
      var m1 = new Mammal("Herb the Mammal");  // forgetting to use "new" here will cause will cause 
      console.log(m1.getName());
      console.log(m1.name); // There is no privacy, all variables i.e. name are public.
      
      // Defining an inherits method
      Function.prototype.method = function (name, func) {
        this.prototype[name] = func;
        return this;
      };
      Function.method('inherits', function (Parent) {
        this.prototype = new Parent();
        return this; 
      });
      
      // Define Cat object to inherit from Mammal in a cascade style in one statement
      var Cat = function (name) {
        this.name = name;
        this.saying = "meow";
      }
        .inherits(Mammal)
        .method("purr", function (n) {
          var i, s = "";
          for (i = 0; i < n; i += 1) {
            if (s) {
              s += "-";
            }
            s += "r";
          }
          return s;
        })
        .method("getName", function () {
          return this.says() + " " + this.name + " " + this.says();
        });
      console.log("After adding purr and getName (overwritten) methods");
      console.log(Cat.prototype);
      
      var simba = new Cat("Simba");
      console.log(simba.says());
      console.log(simba.purr(5));
      console.log(simba.getName());
      console.log(simba.name);    // There is no privacy, all variables are public:
      console.log(simba.saying);  // i.e. name and saying are both public
      
      console.log("\n** Functional: The Module Pattern **");
       var mammal = function (spec) {
        var that = {};
        
        that.getName = function () {
          return spec.name;
        };
        
        that.says = function () {
          return spec.saying || '';
        }
        
        var privateMethod = function () {
          spec.wink = " ;)";
          return spec.wink;
        };
        
        that.publicMethod = function () {
          return privateMethod()
        };
        return that;
      };
      
      var person = mammal({name: "Herb"});
      console.log(person);
      console.log(person.that);             // Finally properties in this case "that"
      //console.log(person.privateMethod());  // and "privateMethod()" are private
      console.log(person.publicMethod());  // and "privateMethod()" are private
      
      // Let's define a subclass, cat
      var cat = function (spec) {
        spec.saying = spec.saying || "meow";
        var that = mammal(spec);
        
        that.purr = function (n) {
          var i, s = spec.name + " purrs " + n + " times: ";
          for (i = 0; i < n; i += 1) {
            if (s) {
              s += "-";
            }
            s += "r";
          }
          return s;
        };
        
        that.getName = function () {
          return that.says() + " " + spec.name + " " + that.says();
        };
        
        return that;
      };
      
      var simba = cat({name: "Simba"});
      console.log(simba);
      console.log(simba.that || "the 'that' property is private and therefore not accessible.");
      console.log(simba.publicMethod() + " <- 'publicMethod()' is an inherited method");
      console.log(simba.says() + " <- 'says()' is an inherited method");
      console.log(simba.purr(100));
      console.log(simba.getName());
      
      // Let's define a super method
      Object.method("superior", function (name) {
        var that = this,
            method = that[name];
        
        return function () {
          return method.apply(that, arguments);
        };
      });
      
      // Let's define a subclass of cat
      var coolcat = function (spec) {
        var that = cat(spec),
            superGetName = that.superior("getName");
        
        that.getName = function (n) {
          return "like " + superGetName() + ' baby';
        };
        
        return that;
      };
      
      var simba = coolcat({name: "Simba"});
      console.log(simba);
      console.log(simba.getName());
      console.log(simba.purr(10) + "\t\t\t\t <- 'purr()' is an inherited method");
      console.log(simba.publicMethod() + " <- 'publicMethod()' is an inherited method all the way down to 'mammal'");
   </script>
  </body>
</html>
